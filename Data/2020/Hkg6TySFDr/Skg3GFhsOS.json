{"rating": "6: Weak Accept", "experience_assessment": "I have published one or two papers in this area.", "review_assessment:_checking_correctness_of_derivations_and_theory": "N/A", "review_assessment:_checking_correctness_of_experiments": "I carefully checked the experiments.", "title": "Official Blind Review #3", "review_assessment:_thoroughness_in_paper_reading": "N/A", "review": "This work presets a neural network method for the reverse engineering of binaries. The authors, build the CFG from the assembly, extract the invoked function names and generate sequences of these function calls as they would appear in execution traces. Using these sequences, a set-of-sequences2seqence model is used to predict the subwords of the name of the procedure.\nOverall, the approach seems reasonable, the performance gains are good and the application is important. The paper is also well-written. Therefore, I believe that this paper should get accepted.\n\n* It's unclear to me how the sequences of calls are extracted. Is this exhaustive? How are loops treated?\n\n* A comparison to a GNN-based architecture would certainly strengthen the paper. I imagine a GNN (such as a GCN) over the CFG, where the initial node states are the output of the `encode_callsite`. This would certainly be interesting and _might_ be relatively easy since the authors seem to already construct the graph.\n\nMinor:\n* p6 \"LSTMS\" -> \"LSTMs\""}